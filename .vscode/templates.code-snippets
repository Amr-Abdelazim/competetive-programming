{
	// Place your competetive-programming workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"my-template":{
		"prefix": "!!init",
		"body": ["#ifdef ONLINE_JUDGE",
			"#include <bits/stdc++.h>",
			"// For ordered_set",
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"#else",
			"#include \"precompiled.h\"",
			"#endif",
			"#define ll long long",
			"#define ld long double",
			"using namespace std;",
			"using namespace __gnu_pbds;",
			"template <typename T>",
			"using ord_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
			"const int N = 5e5 + 5, M = 20;",
			"",
			"int Solve()",
			"{",
			"",
			"    return 0;",
			"}",
			"",
			"signed main()",
			"{",
			"    ios::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"    cout.tie(nullptr);",
			"",
			"    int t;",
			"    cin >> t;",
			"    while (t--)",
			"    {",
			"        Solve();",
			"    }",
			"",
			"    return 0;",
			"}",]
	},
	"nCr":{
		"prefix": "!!ncr",
		"body": ["// ^(.*)$   \"\\$1\",",
			"vector<long long> fact, inv_fact;",
			"",
			"long long mod_pow(long long a, long long b, int mod)",
			"{",
			"    long long res = 1;",
			"    while (b > 0)",
			"    {",
			"        if (b % 2 == 1)",
			"        {",
			"            res = (res * a) % mod;",
			"        }",
			"        a = (a * a) % mod;",
			"        b /= 2;",
			"    }",
			"    return res;",
			"}",
			"",
			"void precompute_factorials(int n, int mod)",
			"{",
			"    fact.resize(n + 1);",
			"    inv_fact.resize(n + 1);",
			"    fact[0] = 1;",
			"    for (int i = 1; i <= n; ++i)",
			"    {",
			"        fact[i] = fact[i - 1] * i % mod;",
			"    }",
			"",
			"    for (int i = n; i >= 0; --i)",
			"    {",
			"        inv_fact[i] = mod_pow(fact[i], mod - 2, mod);",
			"    }",
			"}",
			"",
			"long long nCr(int n, int r, int mod)",
			"{",
			"    if (r > n || r < 0)",
			"        return 0;",
			"    return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod;",
			"}",]
	},
	"Bridges":{
		"prefix": "!!Bridges",
		"body": ["// ^(.*)$   \"\\$1\",",
			"",
			"class Bridges",
			"{",
			"public:",
			"    using vii = vector<pair<int, int>>;",
			"    using vvi = vector<vector<int>>;",
			"    using vi = vector<int>;",
			"    using pii = pair<int, int>;",
			"    bool hash_mode, number_of_components;",
			"    int timeDFS = 0, n;",
			"    vi disc, low;",
			"    vector<bool> visited;",
			"    vii bridges;",
			"    vvi adj;",
			"    set<int> nodes;",
			"    map<int, int> node_to_hash, hash_to_node;",
			"",
			"    Bridges(vii edges, int number_of_nodes = -1)",
			"    {",
			"        hash_mode = false;",
			"        number_of_components = 0;",
			"        if (number_of_nodes == -1)",
			"        {",
			"            hash_mode = true;",
			"            for (auto e : edges)",
			"            {",
			"                nodes.insert(e.first);",
			"                nodes.insert(e.second);",
			"            }",
			"            int c = 0;",
			"            for (auto node : nodes)",
			"            {",
			"                node_to_hash[node] = c;",
			"                hash_to_node[c] = node;",
			"                c++;",
			"            }",
			"            number_of_nodes = c;",
			"            for (auto &e : edges)",
			"            {",
			"                e.first = node_to_hash[e.first];",
			"                e.second = node_to_hash[e.second];",
			"            }",
			"        }",
			"        n = number_of_nodes;",
			"        adj = vvi(number_of_nodes);",
			"        for (auto e : edges)",
			"        {",
			"            int u = e.first, v = e.second;",
			"            adj[u].push_back(v);",
			"            adj[v].push_back(u);",
			"        }",
			"    }",
			"",
			"    void dfs(int u, int parent)",
			"    {",
			"        visited[u] = true;",
			"        disc[u] = low[u] = timeDFS++;",
			"",
			"        for (int v : adj[u])",
			"        {",
			"            if (v == parent)",
			"                continue;",
			"",
			"            if (!visited[v])",
			"            {",
			"                dfs(v, u);",
			"                low[u] = min(low[u], low[v]);",
			"                if (low[v] > disc[u])",
			"                {",
			"                    bridges.push_back({u, v});",
			"                }",
			"            }",
			"            else",
			"            {",
			"                low[u] = min(low[u], disc[v]);",
			"            }",
			"        }",
			"    }",
			"    vii original_edges()",
			"    {",
			"        if (!hash_mode)",
			"            return bridges;",
			"        vii ans;",
			"        for (auto b : bridges)",
			"        {",
			"            ans.push_back({hash_to_node[b.first],",
			"                           hash_to_node[b.second]});",
			"        }",
			"        return ans;",
			"    }",
			"    vii get_bridges()",
			"    {",
			"        if (bridges.size())",
			"            return original_edges();",
			"        for (int i = 0; i < n; i++)",
			"        {",
			"            if (!visited[i])",
			"            {",
			"                number_of_components++;",
			"                dfs(i, -1);",
			"            }",
			"        }",
			"        return original_edges();",
			"    }",
			"    void bld_tree_dfs(int u, vector<bool> &comp_num, set<pii> &bridges_set, vvi &components)",
			"    {",
			"        comp_num[u] = (int)components.size() - 1;",
			"        components.back().push_back(u);",
			"        for (auto i : adj[u])",
			"        {",
			"            if (comp_num[i] != -1 || bridges_set.count({u, i}))",
			"                continue;",
			"            bld_tree_dfs(i, comp_num, bridges_set, components);",
			"        }",
			"    }",
			"    pair<vvi, vvi> build_tree()",
			"    {",
			"        get_bridges(); // this will fill bridges vector",
			"        if (number_of_components != 1)",
			"            throw \"The graph not connected!!\";",
			"        vvi components;",
			"",
			"        vector<bool> comp_num(n, -1);",
			"        set<pii> bridges_set;",
			"        for (auto e : bridges)",
			"        {",
			"            bridges_set.insert(e);",
			"            bridges_set.insert({e.second, e.first});",
			"        }",
			"        for (int i = 0; i < n; i++)",
			"        {",
			"            if (comp_num[i] != -1)",
			"                continue;",
			"            components.emplace_back();",
			"            bld_tree_dfs(i, comp_num, bridges_set, components);",
			"        }",
			"        vvi tree(components.size());",
			"        for (auto e : bridges)",
			"        {",
			"            int u = comp_num[e.first], v = comp_num[e.second];",
			"            tree[u].push_back(v);",
			"            tree[v].push_back(u);",
			"        }",
			"        return {tree, components};",
			"    }",
			"};",
			"",]
	},
	"max-seg":{
		"prefix": "!!max_seg",
		"body": ["// ^(.*)$   \"\\$1\",",
			"template <typename T>",
			"class max_seg",
			"{",
			"public:",
			"    max_seg() {}",
			"",
			"    max_seg(vector<T> x)",
			"    {",
			"        a = x;",
			"        n = x.size();",
			"        seg = vector<pair<T, int>>(4 * n);",
			"        bld(0, n - 1, 1);",
			"    }",
			"    T get_max(int l, int r)",
			"    {",
			"        return get(l, r, 0, n - 1, 1).first;",
			"    }",
			"    void update(int dx, T val)",
			"    {",
			"        upd(dx, val, 0, n - 1, 1);",
			"    }",
			"",
			"private:",
			"    vector<T> a;",
			"    vector<pair<T, int>> seg;",
			"    int n;",
			"    void bld(int l, int r, int p)",
			"    {",
			"        if (l > r)",
			"            return;",
			"        if (l == r)",
			"        {",
			"            seg[p].first = a[l];",
			"            seg[p].second = l;",
			"            return;",
			"        }",
			"        int md = (l + r) >> 1;",
			"        bld(l, md, p << 1);",
			"        bld(md + 1, r, p << 1 | 1);",
			"        seg[p] = max(seg[p << 1], seg[p << 1 | 1]);",
			"    }",
			"    pair<T, int> get(int l, int r, int al, int ar, int p)",
			"    {",
			"        if (l > ar || r < al || al > ar)",
			"            return {T(), -1};",
			"        if (al >= l && ar <= r)",
			"        {",
			"            return seg[p];",
			"        }",
			"        int md = (al + ar) >> 1;",
			"        return max(get(l, r, al, md, p << 1), get(l, r, md + 1, ar, p << 1 | 1));",
			"    }",
			"    void upd(int dx, T val, int al, int ar, int p)",
			"    {",
			"        if (dx > ar || dx < al || al > ar)",
			"            return;",
			"        if (al >= dx && ar <= dx)",
			"        {",
			"            a[al] = val;",
			"            seg[p] = {val, al};",
			"            return;",
			"        }",
			"        int md = (al + ar) >> 1;",
			"        upd(dx, val, al, md, p << 1);",
			"        upd(dx, val, md + 1, ar, p << 1 | 1);",
			"        seg[p] = max(seg[p << 1], seg[p << 1 | 1]);",
			"    }",
			"};",]
	},
	"min-seg":{
		"prefix": "!!min_seg",
		"body": ["template <typename T>",
			"class min_seg",
			"{",
			"public:",
			"    min_seg() {}",
			"",
			"    min_seg(vector<T> x)",
			"    {",
			"        a = x;",
			"        n = x.size();",
			"        seg = vector<pair<T, int>>(4 * n), infint;",
			"        bld(0, n - 1, 1);",
			"    }",
			"    T get_min(int l, int r)",
			"    {",
			"        return get(l, r, 0, n - 1, 1).first;",
			"    }",
			"    void update(int dx, T val)",
			"    {",
			"        upd(dx, val, 0, n - 1, 1);",
			"    }",
			"",
			"private:",
			"    vector<T> a;",
			"    vector<pair<T, int>> seg;",
			"    int n;",
			"    void bld(int l, int r, int p)",
			"    {",
			"        if (l > r)",
			"            return;",
			"        if (l == r)",
			"        {",
			"            seg[p].first = a[l];",
			"            seg[p].second = l;",
			"            return;",
			"        }",
			"        int md = (l + r) >> 1;",
			"        bld(l, md, p << 1);",
			"        bld(md + 1, r, p << 1 | 1);",
			"        seg[p] = min(seg[p << 1], seg[p << 1 | 1]);",
			"    }",
			"    pair<T, int> get(int l, int r, int al, int ar, int p)",
			"    {",
			"        if (l > ar || r < al || al > ar)",
			"            return {T(infint), infint};",
			"        if (al >= l && ar <= r)",
			"        {",
			"            return seg[p];",
			"        }",
			"        int md = (al + ar) >> 1;",
			"        return min(get(l, r, al, md, p << 1), get(l, r, md + 1, ar, p << 1 | 1));",
			"    }",
			"    void upd(int dx, T val, int al, int ar, int p)",
			"    {",
			"        if (dx > ar || dx < al || al > ar)",
			"            return;",
			"        if (al >= dx && ar <= dx)",
			"        {",
			"            a[al] = val;",
			"            seg[p] = {val, al};",
			"            return;",
			"        }",
			"        int md = (al + ar) >> 1;",
			"        upd(dx, val, al, md, p << 1);",
			"        upd(dx, val, md + 1, ar, p << 1 | 1);",
			"        seg[p] = min(seg[p << 1], seg[p << 1 | 1]);",
			"    }",
			"};",],
	},
	"min-cnt-seg":{
		"prefix": "!!min_cnt_seg",
		"body": ["class min_cnt_seg",
			"{",
			"public:",
			"    min_cnt_seg(int n)",
			"    {",
			"        reset(n);",
			"    }",
			"    void reset(int n)",
			"    {",
			"        this->n = n;",
			"        seg = vector<pair<int, int>>(4 * n, {inf, 0});",
			"    }",
			"    pair<int, int> get_min(int l, int r)",
			"    {",
			"        return get(l, r, 0, n - 1, 1);",
			"    }",
			"    void update(int dx, int val)",
			"    {",
			"        upd(dx, val, 1, 0, n - 1, 1);",
			"    }",
			"    void update(int dx, pair<int, int> val)",
			"    {",
			"        upd(dx, val.first, val.second, 0, n - 1, 1);",
			"    }",
			"",
			"private:",
			"    vector<pair<int, int>> seg;",
			"    int n;",
			"    void combine(pair<int, int> &dist, pair<int, int> a, pair<int, int> b)",
			"    {",
			"        dist = a;",
			"        if (dist.first > b.first)",
			"            dist = b;",
			"        else if (b.first == dist.first)",
			"            dist.second = (dist.second + b.second) % mod;",
			"    }",
			"    pair<int, int> get(int l, int r, int al, int ar, int p)",
			"    {",
			"        if (l > ar || r < al || al > ar)",
			"            return {inf, 0};",
			"        if (al >= l && ar <= r)",
			"        {",
			"            return seg[p];",
			"        }",
			"        int md = (al + ar) >> 1;",
			"        pair<int, int> ans = {inf, 0};",
			"        combine(ans, get(l, r, al, md, p << 1), get(l, r, md + 1, ar, p << 1 | 1));",
			"        return ans;",
			"    }",
			"",
			"    void upd(int dx, int val, int cnt, int al, int ar, int p)",
			"    {",
			"        if (dx > ar || dx < al || al > ar)",
			"            return;",
			"        if (al >= dx && ar <= dx)",
			"        {",
			"            seg[p] = {val, cnt};",
			"            return;",
			"        }",
			"        int md = (al + ar) >> 1;",
			"        upd(dx, val, cnt, al, md, p << 1);",
			"        upd(dx, val, cnt, md + 1, ar, p << 1 | 1);",
			"        combine(seg[p], seg[p << 1], seg[p << 1 | 1]);",
			"    }",
			"};",]
	},
	"Z-function":{
		"prefix": "!!z_function",
		"body": ["// ^(.*)$   \"\\$1\",",
			"",
			"vector<int> z_function(string s)",
			"{",
			"    int n = s.size();",
			"    vector<int> z(n);",
			"    int l = 0, r = 0;",
			"    for (int i = 1; i < n; i++)",
			"    {",
			"        if (i < r)",
			"        {",
			"            z[i] = min(r - i, z[i - l]);",
			"        }",
			"        while (i + z[i] < n && s[z[i]] == s[i + z[i]])",
			"        {",
			"            z[i]++;",
			"        }",
			"        if (i + z[i] > r)",
			"        {",
			"            l = i;",
			"            r = i + z[i];",
			"        }",
			"    }",
			"    return z;",
			"}",]
	},
	"ModInteger":{
		"prefix": "!!Mint",
		"body": ["template <typename T>",
			"T euclid(T x, T y, T &k, T &l)",
			"{",
			"    if (x < 0)",
			"    {",
			"        T g = euclid(-x, y, k, l);",
			"        k = -k;",
			"        return g;",
			"    }",
			"    if (y < 0)",
			"    {",
			"        T g = euclid(x, -y, k, l);",
			"        l = -l;",
			"        return g;",
			"    }",
			"    if (y == 0)",
			"    {",
			"        k = 1;",
			"        l = 0;",
			"        return x;",
			"    }",
			"    T g = euclid(y, x % y, l, k);",
			"    l -= k * (x / y);",
			"    return g;",
			"}",
			"",
			"uint MOD = 998244353;",
			"struct Mint",
			"{",
			"    uint x;",
			"",
			"    Mint() : x(0) {}",
			"    Mint(ll _x)",
			"    {",
			"        _x %= MOD;",
			"        if (_x < 0)",
			"            _x += MOD;",
			"        x = _x;",
			"    }",
			"",
			"    Mint &operator+=(const Mint &a)",
			"    {",
			"        x += a.x;",
			"        if (x >= MOD)",
			"            x -= MOD;",
			"        return *this;",
			"    }",
			"    Mint &operator-=(const Mint &a)",
			"    {",
			"        x += MOD - a.x;",
			"        if (x >= MOD)",
			"            x -= MOD;",
			"        return *this;",
			"    }",
			"    Mint &operator*=(const Mint &a)",
			"    {",
			"        x = (ull)x * a.x % MOD;",
			"        return *this;",
			"    }",
			"    Mint pow(ll pw) const",
			"    {",
			"        Mint res = 1;",
			"        Mint cur = *this;",
			"        while (pw)",
			"        {",
			"            if (pw & 1)",
			"                res *= cur;",
			"            cur *= cur;",
			"            pw >>= 1;",
			"        }",
			"        return res;",
			"    }",
			"    Mint inv() const",
			"    {",
			"        ll g, k, l;",
			"        g = euclid<ll>(x, MOD, k, l);",
			"        assert(g == 1);",
			"        k %= MOD;",
			"        if (k < 0)",
			"            k += MOD;",
			"        return k;",
			"    }",
			"    Mint &operator/=(const Mint &a)",
			"    {",
			"        return *this *= a.inv();",
			"    }",
			"    Mint operator+(const Mint &a) const",
			"    {",
			"        return Mint(*this) += a;",
			"    }",
			"    Mint operator-(const Mint &a) const",
			"    {",
			"        return Mint(*this) -= a;",
			"    }",
			"    Mint operator*(const Mint &a) const",
			"    {",
			"        return Mint(*this) *= a;",
			"    }",
			"    Mint operator/(const Mint &a) const",
			"    {",
			"        return Mint(*this) /= a;",
			"    }",
			"",
			"    bool operator==(const Mint &a) const",
			"    {",
			"        return x == a.x;",
			"    }",
			"    bool operator!=(const Mint &a) const",
			"    {",
			"        return x != a.x;",
			"    }",
			"    bool operator<(const Mint &a) const",
			"    {",
			"        return x < a.x;",
			"    }",
			"};",]

	},
	"MO_algorithm":{
		"prefix": "!!mo_algo",
		"body": ["",
			"void remove(int idx) {}",
			"void add(int idx) {}",
			"int get_answer() {}",
			"",
			"int block_size;",
			"",
			"struct Query",
			"{",
			"    int l, r, idx;",
			"    bool operator<(Query other) const",
			"    {",
			"assert(block_size > 0);",
			"        return make_pair(l / block_size, r) <",
			"               make_pair(other.l / block_size, other.r);",
			"    }",
			"};",
			"",
			"vector<int> mo_s_algorithm(vector<Query> queries)",
			"{",
			"    vector<int> answers(queries.size());",
			"    sort(queries.begin(), queries.end());",
			"",
			"    int cur_l = 0;",
			"    int cur_r = -1;",
			"",
			"    for (Query q : queries)",
			"    {",
			"        while (cur_l > q.l)",
			"        {",
			"            cur_l--;",
			"            add(cur_l);",
			"        }",
			"        while (cur_r < q.r)",
			"        {",
			"            cur_r++;",
			"            add(cur_r);",
			"        }",
			"        while (cur_l < q.l)",
			"        {",
			"            remove(cur_l);",
			"            cur_l++;",
			"        }",
			"        while (cur_r > q.r)",
			"        {",
			"            remove(cur_r);",
			"            cur_r--;",
			"        }",
			"        answers[q.idx] = get_answer();",
			"    }",
			"    return answers;",
			"}",]
	},
	"LazySegmentTree":{
		"prefix": "!!lazyseg",
		"body": ["",
			"template <typename T>",
			"struct LzySeg",
			"{",
			"    vector<T> seg, lzy;",
			"    int n;",
			"    LzySeg(int size) : n(size)",
			"    {",
			"        seg = vector<T>(4 * n);",
			"        lzy = vector<T>(4 * n);",
			"    }",
			"    T combine(T left, T right)",
			"    {",
			"        return max(left, right);",
			"    }",
			"    void prob(int l, int r, int p)",
			"    {",
			"        if (p >= 4 * n || !lzy[p] || l > r)",
			"            return;",
			"        seg[p] += lzy[p];",
			"        if (l != r)",
			"        {",
			"            lzy[p << 1] += lzy[p];",
			"            lzy[p << 1 | 1] += lzy[p];",
			"        }",
			"        lzy[p] = 0;",
			"    }",
			"    void add(int l, int r, T val, int al, int ar, int p)",
			"    {",
			"        prob(al, ar, p);",
			"        if (al > r || ar < l || al > ar || l > r)",
			"            return;",
			"        if (al >= l && ar <= r)",
			"        {",
			"            lzy[p] += val;",
			"            prob(al, ar, p);",
			"            return;",
			"        }",
			"        int md = (al + ar) >> 1;",
			"        add(l, r, val, al, md, p << 1);",
			"        add(l, r, val, md + 1, ar, p << 1 | 1);",
			"        seg[p] = combine(seg[p << 1], seg[p << 1 | 1]);",
			"    }",
			"    T get(int l, int r, int al, int ar, int p)",
			"    {",
			"        prob(al, ar, p);",
			"        if (al > r || ar < l || al > ar || l > r)",
			"            return T();",
			"        if (al >= l && ar <= r)",
			"        {",
			"            return seg[p];",
			"        }",
			"        int md = (al + ar) >> 1;",
			"        return combine(get(l, r, al, md, p << 1), get(l, r, md + 1, ar, p << 1 | 1));",
			"    }",
			"    void add(int l, int r, T val)",
			"    {",
			"        add(l, r, val, 0, n - 1, 1);",
			"    }",
			"    T get(int l, int r)",
			"    {",
			"        return get(l, r, 0, n - 1, 1);",
			"    }",
			"    T const operator[](int idx)",
			"    {",
			"        return get(idx, idx, 0, n - 1, 1);",
			"    }",
			"};",]
	},
	"BigInt":{
		"prefix": "!!BigInt",
		"body": ["class BigInt",
			"{",
			"    string digits;",
			"",
			"public:",
			"    // Constructors:",
			"    BigInt(unsigned long long n = 0);",
			"    BigInt(string &);",
			"    BigInt(const char *);",
			"    BigInt(BigInt &);",
			"",
			"    // Helper Functions:",
			"    friend void divide_by_2(BigInt &a);",
			"    friend bool Null(const BigInt &);",
			"    friend int Length(const BigInt &);",
			"    int operator[](const int) const;",
			"",
			"    /* * * * Operator Overloading * * * */",
			"",
			"    // Direct assignment",
			"    BigInt &operator=(const BigInt &);",
			"",
			"    // Post/Pre - Incrementation",
			"    BigInt &operator++();",
			"    BigInt operator++(int temp);",
			"    BigInt &operator--();",
			"    BigInt operator--(int temp);",
			"",
			"    // Addition and Subtraction",
			"    friend BigInt &operator+=(BigInt &, const BigInt &);",
			"    friend BigInt operator+(const BigInt &, const BigInt &);",
			"    friend BigInt operator-(const BigInt &, const BigInt &);",
			"    friend BigInt &operator-=(BigInt &, const BigInt &);",
			"",
			"    // Comparison operators",
			"    friend bool operator==(const BigInt &, const BigInt &);",
			"    friend bool operator!=(const BigInt &, const BigInt &);",
			"",
			"    friend bool operator>(const BigInt &, const BigInt &);",
			"    friend bool operator>=(const BigInt &, const BigInt &);",
			"    friend bool operator<(const BigInt &, const BigInt &);",
			"    friend bool operator<=(const BigInt &, const BigInt &);",
			"",
			"    // Multiplication and Division",
			"    friend BigInt &operator*=(BigInt &, const BigInt &);",
			"    friend BigInt operator*(const BigInt &, const BigInt &);",
			"    friend BigInt &operator/=(BigInt &, const BigInt &);",
			"    friend BigInt operator/(const BigInt &, const BigInt &);",
			"",
			"    // Modulo",
			"    friend BigInt operator%(const BigInt &, const BigInt &);",
			"    friend BigInt &operator%=(BigInt &, const BigInt &);",
			"",
			"    // Power Function",
			"    friend BigInt &operator^=(BigInt &, const BigInt &);",
			"    friend BigInt operator^(BigInt &, const BigInt &);",
			"",
			"    // Square Root Function",
			"    friend BigInt sqrt(BigInt &a);",
			"",
			"    // Read and Write",
			"    friend ostream &operator<<(ostream &, const BigInt &);",
			"    friend istream &operator>>(istream &, BigInt &);",
			"",
			"    // Others",
			"    friend BigInt NthCatalan(int n);",
			"    friend BigInt NthFibonacci(int n);",
			"    friend BigInt Factorial(int n);",
			"};",
			"",
			"BigInt::BigInt(string &s)",
			"{",
			"    digits = \"\";",
			"    int n = s.size();",
			"    for (int i = n - 1; i >= 0; i--)",
			"    {",
			"        if (!isdigit(s[i]))",
			"            throw(\"ERROR\");",
			"        digits.push_back(s[i] - '0');",
			"    }",
			"}",
			"BigInt::BigInt(unsigned long long nr)",
			"{",
			"    do",
			"    {",
			"        digits.push_back(nr % 10);",
			"        nr /= 10;",
			"    } while (nr);",
			"}",
			"BigInt::BigInt(const char *s)",
			"{",
			"    digits = \"\";",
			"    for (int i = strlen(s) - 1; i >= 0; i--)",
			"    {",
			"        if (!isdigit(s[i]))",
			"            throw(\"ERROR\");",
			"        digits.push_back(s[i] - '0');",
			"    }",
			"}",
			"BigInt::BigInt(BigInt &a)",
			"{",
			"    digits = a.digits;",
			"}",
			"",
			"bool Null(const BigInt &a)",
			"{",
			"    if (a.digits.size() == 1 && a.digits[0] == 0)",
			"        return true;",
			"    return false;",
			"}",
			"int Length(const BigInt &a)",
			"{",
			"    return a.digits.size();",
			"}",
			"int BigInt::operator[](const int index) const",
			"{",
			"    if (digits.size() <= index || index < 0)",
			"        throw(\"ERROR\");",
			"    return digits[index];",
			"}",
			"bool operator==(const BigInt &a, const BigInt &b)",
			"{",
			"    return a.digits == b.digits;",
			"}",
			"bool operator!=(const BigInt &a, const BigInt &b)",
			"{",
			"    return !(a == b);",
			"}",
			"bool operator<(const BigInt &a, const BigInt &b)",
			"{",
			"    int n = Length(a), m = Length(b);",
			"    if (n != m)",
			"        return n < m;",
			"    while (n--)",
			"        if (a.digits[n] != b.digits[n])",
			"            return a.digits[n] < b.digits[n];",
			"    return false;",
			"}",
			"bool operator>(const BigInt &a, const BigInt &b)",
			"{",
			"    return b < a;",
			"}",
			"bool operator>=(const BigInt &a, const BigInt &b)",
			"{",
			"    return !(a < b);",
			"}",
			"bool operator<=(const BigInt &a, const BigInt &b)",
			"{",
			"    return !(a > b);",
			"}",
			"",
			"BigInt &BigInt::operator=(const BigInt &a)",
			"{",
			"    digits = a.digits;",
			"    return *this;",
			"}",
			"",
			"BigInt &BigInt::operator++()",
			"{",
			"    int i, n = digits.size();",
			"    for (i = 0; i < n && digits[i] == 9; i++)",
			"        digits[i] = 0;",
			"    if (i == n)",
			"        digits.push_back(1);",
			"    else",
			"        digits[i]++;",
			"    return *this;",
			"}",
			"BigInt BigInt::operator++(int temp)",
			"{",
			"    BigInt aux;",
			"    aux = *this;",
			"    ++(*this);",
			"    return aux;",
			"}",
			"",
			"BigInt &BigInt::operator--()",
			"{",
			"    if (digits[0] == 0 && digits.size() == 1)",
			"        throw(\"UNDERFLOW\");",
			"    int i, n = digits.size();",
			"    for (i = 0; digits[i] == 0 && i < n; i++)",
			"        digits[i] = 9;",
			"    digits[i]--;",
			"    if (n > 1 && digits[n - 1] == 0)",
			"        digits.pop_back();",
			"    return *this;",
			"}",
			"BigInt BigInt::operator--(int temp)",
			"{",
			"    BigInt aux;",
			"    aux = *this;",
			"    --(*this);",
			"    return aux;",
			"}",
			"",
			"BigInt &operator+=(BigInt &a, const BigInt &b)",
			"{",
			"    int t = 0, s, i;",
			"    int n = Length(a), m = Length(b);",
			"    if (m > n)",
			"        a.digits.append(m - n, 0);",
			"    n = Length(a);",
			"    for (i = 0; i < n; i++)",
			"    {",
			"        if (i < m)",
			"            s = (a.digits[i] + b.digits[i]) + t;",
			"        else",
			"            s = a.digits[i] + t;",
			"        t = s / 10;",
			"        a.digits[i] = (s % 10);",
			"    }",
			"    if (t)",
			"        a.digits.push_back(t);",
			"    return a;",
			"}",
			"BigInt operator+(const BigInt &a, const BigInt &b)",
			"{",
			"    BigInt temp;",
			"    temp = a;",
			"    temp += b;",
			"    return temp;",
			"}",
			"",
			"BigInt &operator-=(BigInt &a, const BigInt &b)",
			"{",
			"    if (a < b)",
			"        throw(\"UNDERFLOW\");",
			"    int n = Length(a), m = Length(b);",
			"    int i, t = 0, s;",
			"    for (i = 0; i < n; i++)",
			"    {",
			"        if (i < m)",
			"            s = a.digits[i] - b.digits[i] + t;",
			"        else",
			"            s = a.digits[i] + t;",
			"        if (s < 0)",
			"            s += 10,",
			"                t = -1;",
			"        else",
			"            t = 0;",
			"        a.digits[i] = s;",
			"    }",
			"    while (n > 1 && a.digits[n - 1] == 0)",
			"        a.digits.pop_back(),",
			"            n--;",
			"    return a;",
			"}",
			"BigInt operator-(const BigInt &a, const BigInt &b)",
			"{",
			"    BigInt temp;",
			"    temp = a;",
			"    temp -= b;",
			"    return temp;",
			"}",
			"",
			"BigInt &operator*=(BigInt &a, const BigInt &b)",
			"{",
			"    if (Null(a) || Null(b))",
			"    {",
			"        a = BigInt();",
			"        return a;",
			"    }",
			"    int n = a.digits.size(), m = b.digits.size();",
			"    vector<int> v(n + m, 0);",
			"    for (int i = 0; i < n; i++)",
			"        for (int j = 0; j < m; j++)",
			"        {",
			"            v[i + j] += (a.digits[i]) * (b.digits[j]);",
			"        }",
			"    n += m;",
			"    a.digits.resize(v.size());",
			"    for (int s, i = 0, t = 0; i < n; i++)",
			"    {",
			"        s = t + v[i];",
			"        v[i] = s % 10;",
			"        t = s / 10;",
			"        a.digits[i] = v[i];",
			"    }",
			"    for (int i = n - 1; i >= 1 && !v[i]; i--)",
			"        a.digits.pop_back();",
			"    return a;",
			"}",
			"BigInt operator*(const BigInt &a, const BigInt &b)",
			"{",
			"    BigInt temp;",
			"    temp = a;",
			"    temp *= b;",
			"    return temp;",
			"}",
			"",
			"BigInt &operator/=(BigInt &a, const BigInt &b)",
			"{",
			"    if (Null(b))",
			"        throw(\"Arithmetic Error: Division By 0\");",
			"    if (a < b)",
			"    {",
			"        a = BigInt();",
			"        return a;",
			"    }",
			"    if (a == b)",
			"    {",
			"        a = BigInt(1);",
			"        return a;",
			"    }",
			"    int i, lgcat = 0, cc;",
			"    int n = Length(a), m = Length(b);",
			"    vector<int> cat(n, 0);",
			"    BigInt t;",
			"    for (i = n - 1; t * 10 + a.digits[i] < b; i--)",
			"    {",
			"        t *= 10;",
			"        t += a.digits[i];",
			"    }",
			"    for (; i >= 0; i--)",
			"    {",
			"        t = t * 10 + a.digits[i];",
			"        for (cc = 9; cc * b > t; cc--)",
			"            ;",
			"        t -= cc * b;",
			"        cat[lgcat++] = cc;",
			"    }",
			"    a.digits.resize(cat.size());",
			"    for (i = 0; i < lgcat; i++)",
			"        a.digits[i] = cat[lgcat - i - 1];",
			"    a.digits.resize(lgcat);",
			"    return a;",
			"}",
			"BigInt operator/(const BigInt &a, const BigInt &b)",
			"{",
			"    BigInt temp;",
			"    temp = a;",
			"    temp /= b;",
			"    return temp;",
			"}",
			"",
			"BigInt &operator%=(BigInt &a, const BigInt &b)",
			"{",
			"    if (Null(b))",
			"        throw(\"Arithmetic Error: Division By 0\");",
			"    if (a < b)",
			"    {",
			"        return a;",
			"    }",
			"    if (a == b)",
			"    {",
			"        a = BigInt();",
			"        return a;",
			"    }",
			"    int i, lgcat = 0, cc;",
			"    int n = Length(a), m = Length(b);",
			"    vector<int> cat(n, 0);",
			"    BigInt t;",
			"    for (i = n - 1; t * 10 + a.digits[i] < b; i--)",
			"    {",
			"        t *= 10;",
			"        t += a.digits[i];",
			"    }",
			"    for (; i >= 0; i--)",
			"    {",
			"        t = t * 10 + a.digits[i];",
			"        for (cc = 9; cc * b > t; cc--)",
			"            ;",
			"        t -= cc * b;",
			"        cat[lgcat++] = cc;",
			"    }",
			"    a = t;",
			"    return a;",
			"}",
			"BigInt operator%(const BigInt &a, const BigInt &b)",
			"{",
			"    BigInt temp;",
			"    temp = a;",
			"    temp %= b;",
			"    return temp;",
			"}",
			"",
			"BigInt &operator^=(BigInt &a, const BigInt &b)",
			"{",
			"    BigInt Exponent, Base(a);",
			"    Exponent = b;",
			"    a = 1;",
			"    while (!Null(Exponent))",
			"    {",
			"        if (Exponent[0] & 1)",
			"            a *= Base;",
			"        Base *= Base;",
			"        divide_by_2(Exponent);",
			"    }",
			"    return a;",
			"}",
			"BigInt operator^(BigInt &a, BigInt &b)",
			"{",
			"    BigInt temp(a);",
			"    temp ^= b;",
			"    return temp;",
			"}",
			"",
			"void divide_by_2(BigInt &a)",
			"{",
			"    int add = 0;",
			"    for (int i = a.digits.size() - 1; i >= 0; i--)",
			"    {",
			"        int digit = (a.digits[i] >> 1) + add;",
			"        add = ((a.digits[i] & 1) * 5);",
			"        a.digits[i] = digit;",
			"    }",
			"    while (a.digits.size() > 1 && !a.digits.back())",
			"        a.digits.pop_back();",
			"}",
			"",
			"BigInt sqrt(BigInt &a)",
			"{",
			"    BigInt left(1), right(a), v(1), mid, prod;",
			"    divide_by_2(right);",
			"    while (left <= right)",
			"    {",
			"        mid += left;",
			"        mid += right;",
			"        divide_by_2(mid);",
			"        prod = (mid * mid);",
			"        if (prod <= a)",
			"        {",
			"            v = mid;",
			"            ++mid;",
			"            left = mid;",
			"        }",
			"        else",
			"        {",
			"            --mid;",
			"            right = mid;",
			"        }",
			"        mid = BigInt();",
			"    }",
			"    return v;",
			"}",
			"",
			"BigInt NthCatalan(int n)",
			"{",
			"    BigInt a(1), b;",
			"    for (int i = 2; i <= n; i++)",
			"        a *= i;",
			"    b = a;",
			"    for (int i = n + 1; i <= 2 * n; i++)",
			"        b *= i;",
			"    a *= a;",
			"    a *= (n + 1);",
			"    b /= a;",
			"    return b;",
			"}",
			"",
			"BigInt NthFibonacci(int n)",
			"{",
			"    BigInt a(1), b(1), c;",
			"    if (!n)",
			"        return c;",
			"    n--;",
			"    while (n--)",
			"    {",
			"        c = a + b;",
			"        b = a;",
			"        a = c;",
			"    }",
			"    return b;",
			"}",
			"",
			"BigInt Factorial(int n)",
			"{",
			"    BigInt f(1);",
			"    for (int i = 2; i <= n; i++)",
			"        f *= i;",
			"    return f;",
			"}",
			"",
			"istream &operator>>(istream &in, BigInt &a)",
			"{",
			"    string s;",
			"    in >> s;",
			"    int n = s.size();",
			"    for (int i = n - 1; i >= 0; i--)",
			"    {",
			"        if (!isdigit(s[i]))",
			"            throw(\"INVALID NUMBER\");",
			"        a.digits[n - i - 1] = s[i];",
			"    }",
			"    return in;",
			"}",
			"",
			"ostream &operator<<(ostream &out, const BigInt &a)",
			"{",
			"    for (int i = a.digits.size() - 1; i >= 0; i--)",
			"        cout << (short)a.digits[i];",
			"    return cout;",
			"}",],
	},
	"DisjointSparseTable":{
		"prefix": "!!sparse_table_disjoint",
		"body": ["template <typename T, typename F>",
			"class DisjointSparseTable",
			"{",
			"public:",
			"    int n;",
			"    vector<vector<T>> mat;",
			"    F func;",
			"    DisjointSparseTable(const vector<T> &a, const F &f) : n(int(a.size())), func(f)",
			"    {",
			"        mat.push_back(a);",
			"        for (int p = 1; (1 << p) < n; p++)",
			"        {",
			"            mat.emplace_back(n);",
			"            for (int mid = 1 << p; mid < n; mid += 1 << (p + 1))",
			"            {",
			"                mat[p][mid - 1] = a[mid - 1];",
			"                for (int j = mid - 2; j >= mid - (1 << p); j--)",
			"                {",
			"                    mat[p][j] = func(a[j], mat[p][j + 1]);",
			"                }",
			"                mat[p][mid] = a[mid];",
			"                for (int j = mid + 1; j < min(n, mid + (1 << p)); j++)",
			"                {",
			"                    mat[p][j] = func(mat[p][j - 1], a[j]);",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"    T Query(int l, int r) const",
			"    {",
			"        assert(0 <= l && l < r && r <= n);",
			"        if (r - l == 1)",
			"        {",
			"            return mat[0][l];",
			"        }",
			"        int p = bit_width(unsigned(l ^ (r - 1))) - 1;",
			"        return func(mat[p][l], mat[p][r - 1]);",
			"    }",
			"};",],
	},
	"FenwickTree":{
		"prefix": "!!BIT",
		"body": ["template <typename T>",
			"struct FenwickTree",
			"{",
			"    vector<T> bit;",
			"    int n;",
			"",
			"    FenwickTree(int n)",
			"    {",
			"        this->n = n;",
			"        bit.assign(n, 0);",
			"    }",
			"",
			"    FenwickTree(vector<T> const &a) : FenwickTree(a.size())",
			"    {",
			"        for (int i = 0; i < n; i++)",
			"        {",
			"            bit[i] += a[i];",
			"            int r = i | (i + 1);",
			"            if (r < n)",
			"                bit[r] += bit[i];",
			"        }",
			"    }",
			"",
			"    T sum(int r)",
			"    {",
			"        T ret = 0;",
			"        for (; r >= 0; r = (r & (r + 1)) - 1)",
			"            ret += bit[r];",
			"        return ret;",
			"    }",
			"",
			"    T sum(int l, int r)",
			"    {",
			"        return sum(r) - sum(l - 1);",
			"    }",
			"",
			"    void add(int idx, T delta)",
			"    {",
			"        for (; idx < n; idx = idx | (idx + 1))",
			"            bit[idx] += delta;",
			"    }",
			"};",
			"",]
	},
}