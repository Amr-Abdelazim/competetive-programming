{
	// Place your competetive-programming workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"my-template":{
		"prefix": "!!init",
		"body": ["#ifdef ONLINE_JUDGE",
			"#include <bits/stdc++.h>",
			"// For ordered_set",
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"#else",
			"#include \"precompiled.h\"",
			"#endif",
			"#define ll long long",
			"#define ld long double",
			"using namespace std;",
			"using namespace __gnu_pbds;",
			"template <typename T>",
			"using ord_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
			"const int N = 5e5 + 5, M = 20;",
			"",
			"int Solve()",
			"{",
			"",
			"    return 0;",
			"}",
			"",
			"signed main()",
			"{",
			"    ios::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"    cout.tie(nullptr);",
			"",
			"    int t;",
			"    cin >> t;",
			"    while (t--)",
			"    {",
			"        Solve();",
			"    }",
			"",
			"    return 0;",
			"}",]
	},
	"nCr":{
		"prefix": "!!ncr",
		"body": ["// ^(.*)$   \"\\$1\",",
			"vector<long long> fact, inv_fact;",
			"",
			"long long mod_pow(long long a, long long b, int mod)",
			"{",
			"    long long res = 1;",
			"    while (b > 0)",
			"    {",
			"        if (b % 2 == 1)",
			"        {",
			"            res = (res * a) % mod;",
			"        }",
			"        a = (a * a) % mod;",
			"        b /= 2;",
			"    }",
			"    return res;",
			"}",
			"",
			"void precompute_factorials(int n, int mod)",
			"{",
			"    fact.resize(n + 1);",
			"    inv_fact.resize(n + 1);",
			"    fact[0] = 1;",
			"    for (int i = 1; i <= n; ++i)",
			"    {",
			"        fact[i] = fact[i - 1] * i % mod;",
			"    }",
			"",
			"    for (int i = n; i >= 0; --i)",
			"    {",
			"        inv_fact[i] = mod_pow(fact[i], mod - 2, mod);",
			"    }",
			"}",
			"",
			"long long nCr(int n, int r, int mod)",
			"{",
			"    if (r > n || r < 0)",
			"        return 0;",
			"    return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod;",
			"}",]
	},
	"Bridges":{
		"prefix": "!!Bridges",
		"body": ["// ^(.*)$   \"\\$1\",",
			"",
			"class Bridges",
			"{",
			"public:",
			"    using vii = vector<pair<int, int>>;",
			"    using vvi = vector<vector<int>>;",
			"    using vi = vector<int>;",
			"    using pii = pair<int, int>;",
			"    bool hash_mode, number_of_components;",
			"    int timeDFS = 0, n;",
			"    vi disc, low;",
			"    vector<bool> visited;",
			"    vii bridges;",
			"    vvi adj;",
			"    set<int> nodes;",
			"    map<int, int> node_to_hash, hash_to_node;",
			"",
			"    Bridges(vii edges, int number_of_nodes = -1)",
			"    {",
			"        hash_mode = false;",
			"        number_of_components = 0;",
			"        if (number_of_nodes == -1)",
			"        {",
			"            hash_mode = true;",
			"            for (auto e : edges)",
			"            {",
			"                nodes.insert(e.first);",
			"                nodes.insert(e.second);",
			"            }",
			"            int c = 0;",
			"            for (auto node : nodes)",
			"            {",
			"                node_to_hash[node] = c;",
			"                hash_to_node[c] = node;",
			"                c++;",
			"            }",
			"            number_of_nodes = c;",
			"            for (auto &e : edges)",
			"            {",
			"                e.first = node_to_hash[e.first];",
			"                e.second = node_to_hash[e.second];",
			"            }",
			"        }",
			"        n = number_of_nodes;",
			"        adj = vvi(number_of_nodes);",
			"        for (auto e : edges)",
			"        {",
			"            int u = e.first, v = e.second;",
			"            adj[u].push_back(v);",
			"            adj[v].push_back(u);",
			"        }",
			"    }",
			"",
			"    void dfs(int u, int parent)",
			"    {",
			"        visited[u] = true;",
			"        disc[u] = low[u] = timeDFS++;",
			"",
			"        for (int v : adj[u])",
			"        {",
			"            if (v == parent)",
			"                continue;",
			"",
			"            if (!visited[v])",
			"            {",
			"                dfs(v, u);",
			"                low[u] = min(low[u], low[v]);",
			"                if (low[v] > disc[u])",
			"                {",
			"                    bridges.push_back({u, v});",
			"                }",
			"            }",
			"            else",
			"            {",
			"                low[u] = min(low[u], disc[v]);",
			"            }",
			"        }",
			"    }",
			"    vii original_edges()",
			"    {",
			"        if (!hash_mode)",
			"            return bridges;",
			"        vii ans;",
			"        for (auto b : bridges)",
			"        {",
			"            ans.push_back({hash_to_node[b.first],",
			"                           hash_to_node[b.second]});",
			"        }",
			"        return ans;",
			"    }",
			"    vii get_bridges()",
			"    {",
			"        if (bridges.size())",
			"            return original_edges();",
			"        for (int i = 0; i < n; i++)",
			"        {",
			"            if (!visited[i])",
			"            {",
			"                number_of_components++;",
			"                dfs(i, -1);",
			"            }",
			"        }",
			"        return original_edges();",
			"    }",
			"    void bld_tree_dfs(int u, vector<bool> &comp_num, set<pii> &bridges_set, vvi &components)",
			"    {",
			"        comp_num[u] = (int)components.size() - 1;",
			"        components.back().push_back(u);",
			"        for (auto i : adj[u])",
			"        {",
			"            if (comp_num[i] != -1 || bridges_set.count({u, i}))",
			"                continue;",
			"            bld_tree_dfs(i, comp_num, bridges_set, components);",
			"        }",
			"    }",
			"    pair<vvi, vvi> build_tree()",
			"    {",
			"        get_bridges(); // this will fill bridges vector",
			"        if (number_of_components != 1)",
			"            throw \"The graph not connected!!\";",
			"        vvi components;",
			"",
			"        vector<bool> comp_num(n, -1);",
			"        set<pii> bridges_set;",
			"        for (auto e : bridges)",
			"        {",
			"            bridges_set.insert(e);",
			"            bridges_set.insert({e.second, e.first});",
			"        }",
			"        for (int i = 0; i < n; i++)",
			"        {",
			"            if (comp_num[i] != -1)",
			"                continue;",
			"            components.emplace_back();",
			"            bld_tree_dfs(i, comp_num, bridges_set, components);",
			"        }",
			"        vvi tree(components.size());",
			"        for (auto e : bridges)",
			"        {",
			"            int u = comp_num[e.first], v = comp_num[e.second];",
			"            tree[u].push_back(v);",
			"            tree[v].push_back(u);",
			"        }",
			"        return {tree, components};",
			"    }",
			"};",
			"",]
	},
	"max-seg":{
		"prefix": "!!max_seg",
		"body": ["// ^(.*)$   \"\\$1\",",
			"template <typename T>",
			"class max_seg",
			"{",
			"public:",
			"    max_seg() {}",
			"",
			"    max_seg(vector<T> x)",
			"    {",
			"        a = x;",
			"        n = x.size();",
			"        seg = vector<pair<T, int>>(4 * n);",
			"        bld(0, n - 1, 1);",
			"    }",
			"    T get_max(int l, int r)",
			"    {",
			"        return get(l, r, 0, n - 1, 1).first;",
			"    }",
			"    void update(int dx, T val)",
			"    {",
			"        upd(dx, val, 0, n - 1, 1);",
			"    }",
			"",
			"private:",
			"    vector<T> a;",
			"    vector<pair<T, int>> seg;",
			"    int n;",
			"    void bld(int l, int r, int p)",
			"    {",
			"        if (l > r)",
			"            return;",
			"        if (l == r)",
			"        {",
			"            seg[p].first = a[l];",
			"            seg[p].second = l;",
			"            return;",
			"        }",
			"        int md = (l + r) >> 1;",
			"        bld(l, md, p << 1);",
			"        bld(md + 1, r, p << 1 | 1);",
			"        seg[p] = max(seg[p << 1], seg[p << 1 | 1]);",
			"    }",
			"    pair<T, int> get(int l, int r, int al, int ar, int p)",
			"    {",
			"        if (l > ar || r < al || al > ar)",
			"            return {T(), -1};",
			"        if (al >= l && ar <= r)",
			"        {",
			"            return seg[p];",
			"        }",
			"        int md = (al + ar) >> 1;",
			"        return max(get(l, r, al, md, p << 1), get(l, r, md + 1, ar, p << 1 | 1));",
			"    }",
			"    void upd(int dx, T val, int al, int ar, int p)",
			"    {",
			"        if (dx > ar || dx < al || al > ar)",
			"            return;",
			"        if (al >= dx && ar <= dx)",
			"        {",
			"            a[al] = val;",
			"            seg[p] = {val, al};",
			"            return;",
			"        }",
			"        int md = (al + ar) >> 1;",
			"        upd(dx, val, al, md, p << 1);",
			"        upd(dx, val, md + 1, ar, p << 1 | 1);",
			"        seg[p] = max(seg[p << 1], seg[p << 1 | 1]);",
			"    }",
			"};",]
	},
	"min-cnt-seg":{
		"prefix": "!!min_cnt_seg",
		"body": ["class min_cnt_seg",
			"{",
			"public:",
			"    min_cnt_seg(int n)",
			"    {",
			"        reset(n);",
			"    }",
			"    void reset(int n)",
			"    {",
			"        this->n = n;",
			"        seg = vector<pair<int, int>>(4 * n, {inf, 0});",
			"    }",
			"    pair<int, int> get_min(int l, int r)",
			"    {",
			"        return get(l, r, 0, n - 1, 1);",
			"    }",
			"    void update(int dx, int val)",
			"    {",
			"        upd(dx, val, 1, 0, n - 1, 1);",
			"    }",
			"    void update(int dx, pair<int, int> val)",
			"    {",
			"        upd(dx, val.first, val.second, 0, n - 1, 1);",
			"    }",
			"",
			"private:",
			"    vector<pair<int, int>> seg;",
			"    int n;",
			"    void combine(pair<int, int> &dist, pair<int, int> a, pair<int, int> b)",
			"    {",
			"        dist = a;",
			"        if (dist.first > b.first)",
			"            dist = b;",
			"        else if (b.first == dist.first)",
			"            dist.second = (dist.second + b.second) % mod;",
			"    }",
			"    pair<int, int> get(int l, int r, int al, int ar, int p)",
			"    {",
			"        if (l > ar || r < al || al > ar)",
			"            return {inf, 0};",
			"        if (al >= l && ar <= r)",
			"        {",
			"            return seg[p];",
			"        }",
			"        int md = (al + ar) >> 1;",
			"        pair<int, int> ans = {inf, 0};",
			"        combine(ans, get(l, r, al, md, p << 1), get(l, r, md + 1, ar, p << 1 | 1));",
			"        return ans;",
			"    }",
			"",
			"    void upd(int dx, int val, int cnt, int al, int ar, int p)",
			"    {",
			"        if (dx > ar || dx < al || al > ar)",
			"            return;",
			"        if (al >= dx && ar <= dx)",
			"        {",
			"            seg[p] = {val, cnt};",
			"            return;",
			"        }",
			"        int md = (al + ar) >> 1;",
			"        upd(dx, val, cnt, al, md, p << 1);",
			"        upd(dx, val, cnt, md + 1, ar, p << 1 | 1);",
			"        combine(seg[p], seg[p << 1], seg[p << 1 | 1]);",
			"    }",
			"};",]
	},
	"Z-function":{
		"prefix": "!!z_function",
		"body": ["// ^(.*)$   \"\\$1\",",
			"",
			"vector<int> z_function(string s)",
			"{",
			"    int n = s.size();",
			"    vector<int> z(n);",
			"    int l = 0, r = 0;",
			"    for (int i = 1; i < n; i++)",
			"    {",
			"        if (i < r)",
			"        {",
			"            z[i] = min(r - i, z[i - l]);",
			"        }",
			"        while (i + z[i] < n && s[z[i]] == s[i + z[i]])",
			"        {",
			"            z[i]++;",
			"        }",
			"        if (i + z[i] > r)",
			"        {",
			"            l = i;",
			"            r = i + z[i];",
			"        }",
			"    }",
			"    return z;",
			"}",]
	},
	"ModInteger":{
		"prefix": "!!Mint",
		"body": ["template <typename T>",
			"T euclid(T x, T y, T &k, T &l)",
			"{",
			"    if (x < 0)",
			"    {",
			"        T g = euclid(-x, y, k, l);",
			"        k = -k;",
			"        return g;",
			"    }",
			"    if (y < 0)",
			"    {",
			"        T g = euclid(x, -y, k, l);",
			"        l = -l;",
			"        return g;",
			"    }",
			"    if (y == 0)",
			"    {",
			"        k = 1;",
			"        l = 0;",
			"        return x;",
			"    }",
			"    T g = euclid(y, x % y, l, k);",
			"    l -= k * (x / y);",
			"    return g;",
			"}",
			"",
			"uint MOD = 998244353;",
			"struct Mint",
			"{",
			"    uint x;",
			"",
			"    Mint() : x(0) {}",
			"    Mint(ll _x)",
			"    {",
			"        _x %= MOD;",
			"        if (_x < 0)",
			"            _x += MOD;",
			"        x = _x;",
			"    }",
			"",
			"    Mint &operator+=(const Mint &a)",
			"    {",
			"        x += a.x;",
			"        if (x >= MOD)",
			"            x -= MOD;",
			"        return *this;",
			"    }",
			"    Mint &operator-=(const Mint &a)",
			"    {",
			"        x += MOD - a.x;",
			"        if (x >= MOD)",
			"            x -= MOD;",
			"        return *this;",
			"    }",
			"    Mint &operator*=(const Mint &a)",
			"    {",
			"        x = (ull)x * a.x % MOD;",
			"        return *this;",
			"    }",
			"    Mint pow(ll pw) const",
			"    {",
			"        Mint res = 1;",
			"        Mint cur = *this;",
			"        while (pw)",
			"        {",
			"            if (pw & 1)",
			"                res *= cur;",
			"            cur *= cur;",
			"            pw >>= 1;",
			"        }",
			"        return res;",
			"    }",
			"    Mint inv() const",
			"    {",
			"        ll g, k, l;",
			"        g = euclid<ll>(x, MOD, k, l);",
			"        assert(g == 1);",
			"        k %= MOD;",
			"        if (k < 0)",
			"            k += MOD;",
			"        return k;",
			"    }",
			"    Mint &operator/=(const Mint &a)",
			"    {",
			"        return *this *= a.inv();",
			"    }",
			"    Mint operator+(const Mint &a) const",
			"    {",
			"        return Mint(*this) += a;",
			"    }",
			"    Mint operator-(const Mint &a) const",
			"    {",
			"        return Mint(*this) -= a;",
			"    }",
			"    Mint operator*(const Mint &a) const",
			"    {",
			"        return Mint(*this) *= a;",
			"    }",
			"    Mint operator/(const Mint &a) const",
			"    {",
			"        return Mint(*this) /= a;",
			"    }",
			"",
			"    bool operator==(const Mint &a) const",
			"    {",
			"        return x == a.x;",
			"    }",
			"    bool operator!=(const Mint &a) const",
			"    {",
			"        return x != a.x;",
			"    }",
			"    bool operator<(const Mint &a) const",
			"    {",
			"        return x < a.x;",
			"    }",
			"};",]

	},
}